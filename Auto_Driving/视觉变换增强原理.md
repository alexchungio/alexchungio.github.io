# 视觉变换原理

## 翻转

### 水平翻转

* 原理

  水平翻转可以分为三个步骤

  ​	其中

  * 平移图像垂直中心轴到原点：$T_1=-\frac{B}{2}$
  * 围绕原点垂直中心轴执行图像翻转： $F$
  * 平移图像垂直中心轴到原位置：$T_2=\frac{B}{2}$

  其中$B$为图像右边界坐标，即$w -1$, $F$表示水平翻转矩阵

  完整矩阵
  $$
  \begin{align}
  T =& T_1 @ F @ T_2 \\
  =& 
  \left[
  \begin{matrix}
      1 & \frac{B}{2} \\
      0 & 1 \\
  \end{matrix}
  \right] 
  
  \left[
  \begin{matrix}
      -1 & 0 \\
      0 & 1 \\
  \end{matrix}
  \right]
  
  \left[
  \begin{matrix}
      0 & -\frac{B}{2} \\
      0 & 1 \\
  \end{matrix}
  \right]  \\
  =& 
  \left[
  \begin{matrix}
     -1 & B \\
      0 & 1 \\
  \end{matrix}
  \right]  \\
  \end{align}
  $$
  

* 实现

  ```python
  def _hflip_mat(self, mat, size):
      view = np.eye(4)
      view[0, 0] = -1
      view[0, 2] = size[0] - 1
      mat = view @ mat
      return mat
        
  def __call__():
    size = img.size
    if hflip:
      data["img"][i] = img.transpose(method=Image.FLIP_LEFT_RIGHT)
      if "ego2img" in data:
          ego2img = self._hflip_mat(data["ego2img"][i], size)
  ```

  

## 旋转

### 中心旋转

* 原理

  围绕图像中心B旋转可分为三个步骤

  * 平移图像中心点B到原点: $T_1=-B$

  * 围绕原点旋转: $R=A$

  * 平移图像中心点到原位置 $T_2=B$

  其中$B$ 为中心点坐标，$A$为旋转矩阵

  完整的转换矩阵

$$
\begin{align}
T =& T_1 @ A @ T_2 \\
=& 
\left[
\begin{matrix}
    I & -B \\
    0 & 1 \\
\end{matrix}
\right] 

\left[
\begin{matrix}
    A & 0 \\
    0 & 1 \\
\end{matrix}
\right]

\left[
\begin{matrix}
    I & B \\
    0 & 1 \\
\end{matrix}
\right]  \\
=& 
\left[
\begin{matrix}
    A & A@-B+B \\
    0 & 1 \\
\end{matrix}
\right]  \\
\end{align}
$$



* 实现

  ```python
  def _get_rot(self, rot):
        return torch.Tensor(
            [[np.cos(rot), np.sin(rot)],
             [-np.sin(rot), np.cos(rot)],
            ])
  
  def _rot_mat(self, mat, rot, size):
      """
     	transform matrix rotate
      """
      view = np.eye(4)
      A = self._get_rot(rot / 180 * np.pi)
      B = torch.Tensor([size[0] - 1, size[1] - 1]) / 2
      view[:2, :2] = A
      view[:2, 2] = A @ -B + B
      if mat.shape[-1] == 3:
          mat = view[:3, :3] @ mat
      else:
          mat = view @ mat
      return mat
    
  def rotate(self, point, rot, size):
    	"""
    	point rotate
    	"""
      A = self._get_rot(rot / 180 * np.pi)
      B = torch.Tensor([size[0] - 1, size[1] - 1]) / 2
      trans = A @ -B + B
      point = torch.Tensor(point)
      point = point @ A.T + trans
      return point
    
  def __call__():
    	size = img.size
      if rotate:
    			data['img'][i] = img.rotate(rot)
          if "ego2img" in data:
          		ego2img = self._rot_mat(data["ego2img"][i], rot, size)
  ```

  
